<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>いじるソフトをどう決めるか</title>

<style>
h1 {
  font-size   : 18pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt ;
   
  border-color     : #99A1AA;
  background-color : #DDDDEE;
}

h2 {
  font-size   : 16pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt ;
   
  border-color     : #99A1AA;
  background-color : #EEEEFF;
}

h3 {
  font-size   : 14pt;
  font-family : serif;
  margin      : 10pt 10pt 10pt 20pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt;
  border-color     : #99A1AA;
  background-color : #EEEEFF;
}

div {
  font-size   : 14pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-color     : #99A1AA;
}

div.analects {
  font-size   : 14pt;
  font-family : serif;
  margin      : 10pt 10pt 10pt 550pt;
  padding     : 3pt 20pt;
  background-color : #ffd;
  border-color     : #99A1AA;
}

p {
  font-size   : 14pt;
  font-family : serif;
  border-color     : #99A1AA;
}

pre {
  background-color:#efe;
}

</style>
</head>

<body>
  <a href=../ >home</a>
<h1>いじるソフトをどう決めるか?</h1>
<div>
<font size=-1>(the page is encoded in UTF-8)</font>
</div>

<h2>前提</h2>
<div>
以下は，何かソフトをいじれ，
と言われてもよくわからないという人のためのとっかり．
「自分はこれだ」というのがある人は，
見る必要はありません
</div>

<h2>自分が普段使っているソフト</h2>
<div>
まずは自分が普段使っているソフトを思い出してみると良いだろう．そういうソフトであればある程度機能も把握しているだろうから，どのような変更をする余地があるのか，どうすればうれしいのかもイメージしやすい．
<ul>
  <li>ブラウザ</li>
  <li>シェル</li>
  <li>よく使うコマンド群(ls, less, grep, sort, ...)</li>
  <li>エディタ</li>
  <li>コンパイラ</li>
  <li>オフィス系</li>
  <li>ドローソフト</li>
  <li>音楽録音・再生</li>
  <li>動画録画・再生</li>
  <li>静止画</li>
  <li>ゲーム</li>
  <li>...</li>
</ul>
</div>

<h2>Ubuntuソフトウェアセンター</h2>
<div>
  「Ubuntuソフトウェアセンター」を立ち上げると，
  パッケージでただちにインストールできる
  ソフトウェアの要約を見ることができる．
  眺めるには時間がかかるが広範な選択肢を，
  その要約と共に見られるので，
  貴重な情報源である．
  自分が，名称を知らずに使っていたソフトの名称
  がわかることもある．
</div>

<h2>基盤系ソフト</h2>
<div>
迷ったら，コンピュータの根幹と言って良いソフトたち，
に戻ってみるのはいいかもしれない．
  <ul>
    <li>プログラミング言語: 例えばスクリプト言語などで，
      使ったことがあるものがあれば
      (Python, ruby, javascript)それをいじってみる
    </li>
    <li>オペレーティングシステム: Linux, FreeBSDなど，
    ソースが公開されているOSを探求してみる(上級者向け)</li>
    <li>データベース: SQLite, MariaDB, Postgresqlなどが，
      フリーソフトとしては有名だが，
      ソフトの規模，取り回しの良さという意味では
      SQLiteが圧倒的にシンプルでオススメである．
      すでにデータベースを使ったことがある，という
      人以外にはSQLiteを推奨する．
      </li>
  </ul>
</div>

<h2>ポピュラーなソフト</h2>
<div>
  Linux popular softwareなどのキーワードで検索すると，
  人気のあるLinuxソフトが出てくる．
</div>

<h1>ソフトをどう改良するか?</h1>
<div>
<p>
なにか，そのソフトにふさわしい機能拡張が思いつ
けばこんなによいことはないが，それなりの蓄積の
あるソフトウェアに対していきなり新規参入者が簡
単に思いつけるものでもない．
</p>
<p>
とっかかりとして，いくつかのよくある方向性を示唆しておく
(あまり選択肢を限定するのが本意ではないので，あくまで
煮詰まった時，あるいはとっかかりとして利用して下さい)
</p>
  <ul>

    <li>巨大データを扱えるようにする. 例えばス
      プレッドシートなどデータを扱うプログラム
      や，グラフの描画など，データがでかくなる
      といかにもきつくなりそうなプログラムを対
      象に，その限界を高めるような工夫を行う．
      </li>

    <li>高速化．言語処理系，データベースなどの
      基盤系ソフトウェアや，画像処理，動画処理
      などマルチメディア系のソフトウェアを高速
      化する．ただし，そもそもどこをいじったら
      高速化するか自体が大きな探求になるので，
      結果的に速くならなくても，ボトルネックを
      見つける事自体に価値を感じながら臨むこと
      が必要かもしれない．</li>

    <li>並列化．高速化の中でも，複数のCPUを使っ
      て処理を並列化するのは，もしその仕組みが
      既に実装されていなければ，そこそこの成功
      率が見込める高速化である．</li>

    <li>好きなソフト．普段使っている，愛着のあ
      るソフトウェアであれば，欲しい機能を思い
      つくのは比較的容易かも知れない．</li>

    <li>バグチケット: バグのないソフトウェアは
      存在しない．多くのオープンソースのソフト
      ウェエアプロジェクトはバグを公開し，担当
      者をアサインするための，バグチケットシス
      テムを持っている．そのようなチケットシス
      テムに書かれているバグを見つけて，治そう
      と試みる．地味だがうまくいけば重要な貢献
      ができるかも知れない．
    </li>

    <li>自動操縦．主にGUIを想定して書かれてい
      るアプリケーションを，プログラムで操れる
      ようにしてみる．例えば，お絵かきソフトで，
      100個のオブジェクトを整然と配置させると
      か．ただし，実際には多くのソフトが，マク
      ロと呼ばれる機能で似たようなことを実現し
      ているので，機能的に見劣りしないものを作るのは難しい．
    </li>

    <li><a href=https://summerofcode.withgoogle.com/projects/ >
	Google Summer of Code</a>とかで，
	進行中のプロジェクトの実例を見てみる．
      ただし，聞いたこともないソフトに関する記述を見ても，
      よくわからないかもしれない．
    </li>
  </ul>
</div>

<h1>ブラック(?)リスト</h1>

<div>
  <p>
    ブラックリストというのは多少言い過ぎで,
    ブラック(なソフトの)リストというくらいか.
    これらを選ぼうとする人に「やめろ」というのが目的ではありません.
    これらを選ぶ人に, 一応過去苦労した人がいるということを伝えておく
    (選ぶときはわかって選んでね)のが目的です.
  </p>
  <p>
  主な苦労の元は, 普通にビルドするだけでも苦労する・時間がかかりすぎる,
  ということで, つまりは本題のスタートの前に随分時間がかかって,
  敗北感が生まれてしまうというものです.
  過去のレポートを見てビルドの手順を真似することで,
  軽減される可能性も大いにあります.
  そのような観点から情報を提供します.
  </p>
  <p>
    そもそも本課題のテーマは,
    全容を把握しきれないソフトに立ち向かう方法ですから,
    大きすぎる・複雑すぎるので苦労するからもっと
    簡単・単純なソフトを選びましょう,
    ということにこだわると目的を見失うという説もあります.
    したがって自分がそれに立ち向かう勇気(やる気)があれば,
    大いに選んでもらってよいのですが, なにしろわずか数週間の課題ですから,
    あまり本題と関係ないところで時間をかけすぎると充実感が失われ,
    敗北感が残ってしまうのも確かです. そのような観点から,
    過去におきたことの知見として記します.
  </p>
  <ul>
    <li>Libreoffice
      <a href="https://qiita.com/KRiver1/items/2188d71d316a28ad23ac">
        過去の例1, 
      </a>
      <a href="http://memonya.hatenadiary.com/">
        過去の例2
      </a>
    </li>
    <li>Mozc :
      <a href="https://doss-gitlab.eidos.ic.i.u-tokyo.ac.jp/36/Mozc/blob/master/reports/03140445_nakazawa.md" target="_black">過去の例</a>
      : Google様のソフトで, ビルドの手順などが独創的(独尊的?).
      もしかするとMac OSでやっていたことで災いが悪化していた可能性も</li>
    <li>Chromium
      <a href="https://doss-gitlab.eidos.ic.i.u-tokyo.ac.jp/superbrowser/chromium-kai/blob/master/%E5%A4%A7%E8%A6%8F%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E6%A8%A1report.md"> 過去の例</a>
      Google様である上, 巨大. ビルドに時間がかかりすぎる.</li>
  </ul>
</div>

<h1>定番リスト</h1>

<div>
  やや, 「定番」化してしまった感のあるソフト. これを選ぶなという意味ではないし,
  これを選んだ先人(特に初期の開拓者)をdismissする意図ではありませんが,
  周りをぎゃふん(死語)と言わせたければ他を選んだほうがいいかなと思われるもの
  <ul>
    <li>Pythonに演算子や構文を追加する.
      Pythonにお世話になっているのでPythonをいじってみたいという向きは,
      <a href="https://www.modular.com/mojo"
         target="_blank">Mojo</a>,
      <a href="https://julialang.org/" target="_blank">Julia</a>
      などに手を出すことを考えてみては?
      同じPythonでも演算子や構文追加以外の方向を考えるのは十分ありです.
    </li>
  </ul>
</div>


<h1>思いつきリスト</h1>

<!------------------------------------------------->
<h2>(2023 田浦が本当に本当に欲しい) Inkscapeに,
  レイヤごとに保存する機能を追加
</h2>
<div>
  <ul>
  <li>対象: <font color=blue>inkscape</font></li>
  <li>もともと何をするソフトか: 描画ツール</li>
  <li>背景説明: inkscapeには「レイヤ」という機能があり,
    複数の図形をレイヤに配置して表示・非表示などを操作できる.
    そしてファイルからあるレイヤだけを取り出して,
    ひとつのinkscapeのファイルから複数の絵を取り出すことが出来る.
    手動であるレイヤだけを表示してから保存すれば
    保存すればそのレイヤだけが保存されるが,
    10個もレイヤがあると手動でやってはいられない.
    関連する機能としてコマンドラインから
    <pre>
      inkscape 入力ファイル --export-plain-svg -o 出力ファイル --export-id=ID --export-id-only</pre>
    というコマンドで, 特定のIDを持った図形やグループだけを取り出したファイルを
    書き出す機能があり, 書き出したいレイヤのグループIDがわかれば,
    一レイヤだけを取り出すことも可能だが,
    書き出したいレイヤのグループIDはファイルの開いてみないとわからない
  </li>
  <li>変更案説明:
    <ul>
      <li>「レイヤを保存」のようなメニューで, 全レイヤを
        (一レイヤを一ファイルに)書き出す機能を実装する, または
      </li>
      <li>コマンドラインに, <tt>--export-layer n</tt>のようにして,
        n番目のレイヤを書き出せるようにしたり,
        <tt>--export-all-layers</tt>のようにして,
        全レイヤを書き出せるようにする
      </li>
    </ul>
  </li>
  </ul>
</div>

<!------------------------------------------------->
<h2>(2023 田浦が本当に本当に欲しい) Inkscapeに「複数レイヤに所属するオブジェクト」機能を追加</h2>
<div>
  <ul>
    <li>対象: <font color=blue>inkscape</font></li>
    <li>もともと何をするソフトか: 描画ツール</li>
    <li>背景説明: inkscapeにはレイヤという機能があり,
      複数の図形をレイヤに配置して表示・非表示などを操作できる.
      そしてファイルからあるレイヤだけを取り出して, ひとつのinkscapeのファイル
      から複数の絵を取り出すことが出来る.
      この機能は, 少しずつ異なった絵をいっぱい書くときなどに重宝する.
      例えば四角形が徐々に増えていくアニメーションなどをする場合に便利.
      しかし現状の欠点として, ある図形は一つのレイヤにしか所属できない.
      したがって四角形が徐々に増えていくアニメーションを書きたければ,
      最初からある四角形は全レイヤに書かなければならない.
      コピーすればよいのだが, そうすると後からそれを変更したり,
      動かしたくなったときが大変なことになる.
    </li>
    <li>変更案説明:
      図形はひとつで, それが全レイヤに表示される, という機能を実装する.
      またはより一般化して, レイヤ$n$に作ったオブジェクトを,
      別途指定したレイヤにも表示する(存在しているかのように扱う)機能を
      実装する. パワーポイントなどでアニメーションをするときに,
      あるタイミングから表示されて, あるタイミングで消えるみたいなことが
      できるようにする
    </li>
  </ul>
</div>

<!------------------------------------------------->
<h2>Juliaで何か</h2>
<div>
  <ul>
    <li>対象: <font color=blue>Julia</font></li>
    <li>もともと何をするソフトか: プログラミング言語</li>
    <li>背景説明: 
      JuliaはPythonのような対話的なプログラミングが可能,
      型の指定が不要でありながら, Just-In-Timeコンパイルによって高速な実行が可能
      な言語(Just-In-Timeコンパイル：大雑把に言えばある関数が初めて
      呼び出されたときにコンパイルされる. その際に, 渡された引数の
      型に応じて最適化されたコードを生成してくれる).
      しかしその性質上すべてのコードはコンパイルされながら実行されるので,
      どんなプログラムでもコンパイラが必要とするメモリ(100MB近く)や,
      コンパイルのための実行時間を要する. これをなんとかしたい
    </li>
    <li>変更案説明(以下は一例です):
      <ul>
        <li>軽量コンパイルモードの導入：
          あまり最適化をせずに, コンパイルの回数や時間を最小化する.
          コンパイラそのものを作るのは無理と思われる.
          LLVMというコンパイラを呼び出しているのでその呼び方を調節する程度を想定. ただしこういう機能はすでにundocumentedな機能として存在している可能性もある. そうなったらそうなったで目標を変更すれば良い
        </li>
        <li>コンパイル時間などの詳細を表示する機能の追加.
          これも始めから存在している可能性がある
        </li>
        <li>コンパイルしないモードの導入</li>
        <li>Ahead-Of-Time コンパイルモードの導入.
          始めから(指定された型で)全部コンパイルしておくモード.
          ただし現状のJuliaの処理系にそれを入れ込むことは困難な可能性もある.
        </li>
      </ul>
    </li>
  </ul>
</div>
  
<!------------------------------------------------->
<h2>Mojoで何か</h2>
<div>
  <ul>
    <li>対象: <font color=blue>Mojo</font></li>
    <li>もともと何をするソフトか: プログラミング言語</li>
    <li>背景説明: 
      <a href="https://www.modular.com/mojo" target="_blank">
        Mojo</a>はほぼPythonの文法を保ちつつ高速を売りにした言語.
      田浦はそれ以上の経験・知識はありません.
      Pythonでなにかやってみたい, けど定番と言われちゃった...
      という向きはMojoにふれる機会だと
      思ってとにかくやってみるとよいかも(演算子の追加でもOK)
    </li>
  </ul>
</div>

<h2>(2023 田浦が本当に本当に欲しい) SQLite3 コマンドでユーザ定義関数を使いたい</h2>
<div>
  <ul>
    <li>対象: <font color=blue>SQLite command shell</font> </li>
    <li>元々なにをするソフトか: データベース</li>
    <li>問題の背景: SQLiteは手軽な(1データベース=1ファイルで,
      サーバなしで動作する)データベースソフトで, プログラムから手軽に
      呼び出せる(C APIやPython APIなどがある)他,
      シェルから呼び出せるコマンド(sqlite3)もある. 以下のような感じ
<pre>
$ <u>sqlite3 foo.sqlite</u>
SQLite version 3.22.0 2018-01-22 18:45:57
Enter ".help" for usage hints.
sqlite> <u>create table foo(x,y);</u>
sqlite> <u>insert into foo values(1,2);</u>
sqlite> <u>select x + y from foo;</u>
1|2
</pre>
ちなみにPythonの場合は以下のような感じ.
<pre>
&gt;&gt;&gt; <u>import sqlite3</u>
&gt;&gt;&gt; <u>co = sqlite3.connect("bar.sqlite")</u>
&gt;&gt;&gt; <u>co.execute("create table bar(x,y)")</u>
&gt;&gt;&gt; <u>co.execute("insert into bar values(1,2)")</u>
&gt;&gt;&gt; <u>co.execute("select x + y from bar").fetchall()</u>
[(3,)]
</pre>
    </li>
    どんなデータベースでも, stored procedureとか,
    user defined functionなど, データベースクエリ(select文)中で
    呼び出せる関数を定義する機能がある.
    <font color="red">しかしSQLiteでは, CやPythonの
      API経由でならuser defined関数を定義できるのに,
      コマンドラインでは出来ない.</font>
    例えば C API でなら
    <a href="https://www.sqlite.org/capi3ref.html#sqlite3_create_function">
      sqlite3_create_function
    </a>, Python APIなら,
    <a href="https://docs.python.org/ja/3/library/sqlite3.html">
      create_function
    </a>
    <li>変更案説明
      sqlite3コマンドラインから, PythonやC言語で定義されたユーザ定義関数をロードできるようにする. イメージ図
      (詳細はC, Python API呼び出しに容易に変換できるよう仕様を決めれば良い)
<pre>
sqlite> load_udf fun.py ...
sqlite> load_udf fun.so ...
</pre>      
    </li>

  </ul>
</div>


<!------------------------------------------------->
<h2>Big Gnumeric: Gnumericを巨大データに対応させる</h2>
<div>
<ul>
  <li>対象: <font color=blue>gnumeric</font></li>
  <li>もともと何をするソフトか: 表計算</li>
  <li>背景説明: 表計算で扱えるデータの大きさには制限がある．
  </li>
  <li>変更案説明: 
    一つのワークシートに収められるデータ(行と列のサイズ)の上限を調べ，
    極力その制限を緩和する．メモリを節約できるような表現形式を
    考えても良いし，ファイルの内容全てをメモリに保持しなくても
    動作するようにできれば素晴らしい．
  </li>
</div>

<!------------------------------------------------->
<h2>Makeの可視化機能</h2>
<div>
<ul>
  <li>対象: <font color=blue>make</font></li>
  <li>もともと何をするソフトか: 依存関係にもとづいてコマンドを実行する</li>
  <li>背景説明: ソフトウェア構築に必ずと言っていいほど使われるmakeは，
    ターゲット(通常はファイル名)とその依存関係をMakefileから読み取り，
    ファイルの存否および更新日付にしたがって，実行するコマンドを決定する．
    オープンソース・ソフトウェアをビルドする時，makeと叩くだけで
    多数のコマンドが実行されるのもこの仕組みによる．
    一方，昨今のオープンソースプロジェクトは，
    configureによって，ほとんど人間には解読不能な
    巨大なMakefileを生成する．そのため，makeを実行した時に
    なぜか予期しないコマンドが動作してしまうような場合，
    その原因を探るのは非常に難しい．
  </li>
  <li>変更案説明: makeにオプションを追加して，ターゲット間の依存関係と，
    ファイルの更新日時などを，グラフ構造として視覚化できるようにする．
    なお，グラフの可視化はgraphvizというツールを使えば，
    簡単に行えるので，実質的にはターゲットと，
    依存関係をテキストファイルとして出力すればよい．
  </li>
</div>




<!--
<h2>(2018王) ブラウザで
  通常ウインドウとシークレットウインドウをまたがったタブの移動を可能にする</h2>
<div>
  <ul>
    <li>対象: <font color=blue>Chromium（もしくはFirefox）</font> </li>
    <li>問題の背景: Chromeでは，通常ウインドウ同士，
      シークレットウインドウ同士ではタブをドラッグ
      して移動できるのですが，
      通常ウインドウとシークレットウインドウをまたがったタブ
      のドラッグ移動はできない.</li>
    <li>変更案: 通常ウインドウとシークレットウインドウをまたがった
      ドラッグ移動ができるようになると便利だと思いました．
      考えられる方針:
      <ol>
        <li>タブをドラッグすると，URLをコピーして読み込み直す．</li>
        <li>タブをドラッグするとひとまず表示内容のみを移動し，Cookieなどは移動しない．
          （よって，ページ移動時は挙動がおかしくなる可能性がある．）</li>
        <li>タブをドラッグすると，表示内容とともにCookieの差分もコピーする．
    （例えばシークレットであるサイトにログインした場合，通常にタブを移動したら
          ログイン状態を通常に引き継ぐ．）</li>
      </ol>
    </li>
  </ul>
</div>

<h2>(2018王) Visual Studio Code (VSCode) で，
  差分エディタにおける改行表示の有効化</h2>

<div>
  <ul>
    <li>対象: <font color=blue>VSCode</font> </li>
    <li>元々なにをするソフトか: エディタ</li>
    <li>問題の背景: 
VSCode（というかほとんどのエディタ）では通常長い文章を表示させる場合はそのまま
スクロールバーを付けるか折返し表示をするか設定できます．
ところが，VSCodeでは2ファイルの差分を表示させる際に折返し表示させることが
      できない.

      <img src="img/nowrap_at_diff.png" />
    </li>
    <li>調べてみたら，
      <a href=https://github.com/Microsoft/vscode/issues/11387>
        VSCodeのissue</a>に載っている.
      現状assigneesもいないので直せば採用される可能性もある
    </li>
  </ul>
</div>

<h2>(2018王) Wordの書体ショートカットキー（太字や斜体など）をTeXエディタへの実装</h2>
<div>

  <ul>
    <li>対象: <font color=blue>TeXWorks (など)</font> </li>
    <li>元々なにをするソフトか: TeX用のGUIエディタ</li>
    <li>問題の背景: TeXは,
      数式などを含んだ文書をきれいに組版(typeset)するプログラム.
      普通のワープロのように, 直接印刷イメージを見ながら編集するのはなく,
      編集は普通のテキストエディタにTeXのコマンドを入力する
      (例えばある文字を太字にしたければ, {\bf このように}入力する).
      TeXWorksはTeXのソースを入力するためのエディタ.
      TeXWorksをTeX初心者にとって便利にするため,
      Wordで使うような書体ショートカットキーで
      対応するTeXコマンドが挿入されるようにする
      （例えば太字にしたい場合, "Ctrl + B"を入力すると,
      "{\bf }"が入力されるようにする）.
    </li>
    <li>ただし，
      たぶん多くのエディタ(VSCode, Atom, Emacsなど)で,
      そのような機能はソースを変更せずに拡張機能やプラグイン
      として開発できるので，ゴールとしていまいちかもしれない.
    </li>
    <li>(田浦) TeXWorksを普段使っていないが,
      このエディタには他にも改良の余地があるのではないかと思う.
      4年生になったらTeXで卒論を書くことに成るので今のうちに使って
      おきたいという人はやってみるといいかも.
    </li>
  </ul>
</div>
-->

<h2>(2019 田浦が本当に本当に欲しかった) Remmina Remote Desktopで多数のクライアントと気持ちよく繋げる機能</h2>
<div>
  <ul>
    <li>昔は本当にほしいと思っていが今はZoomにつないでねといえばしまい
      な時代になったのでややdeprecated. ただしすべてをクラウド経由にしたくない,
      という話は今もある
    </li>
    <li>対象: <font color=blue>Remmina</font> </li>
    <li>元々なにをするソフトか: デスクトップ共有クライアント</li>
    <li>問題の背景: デスクトップ共有(remote desktop)は
      他の人と画面を共有できる便利な機能.
      Ubuntu 標準のデスクトップ共有クライアント(Remmina)では,
      複数のマシンと同時につないで複数のマシンの画面を見ることはできるものの,
      それを多数とやると何かと問題がある.
      
      
      教員をやっていると学生の進捗把握やハマっているところを発見するのに,
      <font color=red>多人数, 例えば教室にいる全員
        (例: 30人)と同時に接続できたらな...</font>と思う.
      このような機能は教室用の専用ソフトウェアの機能としてしばしば実現されているが,
      これを普通のデスクトップ共有機能の機能にできたらよい.
    </li>
    <li>変更案説明: 
      <ul>
        <li>クライアント(人の画面を見る方, 例えば教員)が,
          サーバ(見られる方, 例えば学生)の
          IPアドレスを指定して繋がないといけないので, 多数とつなげようと思うと
          手間がかかる.
          操作を逆にして, サーバ(学生)がクライアントを指定して繋げると,
          画面が共有される, という操作モードがあると良い</li>
        <li>発展2: 確認していないがおそらく, Remminaでは,
          クライアントがサーバの画面を表示していようといまいと,
          画面情報が常に通信されている.
          これでは多人数と快適に接続を保ち続けるのは恐らく困難である.
          (実際やってみると, しばしばRemminaが再起不能になる)</li>
        <li>発展1: 首尾よく全員に接続できたとしても,
          それらは異なるタブに表示されるので全員の画面を一望できない.
          教室用ソフトでは, サムネールのような,
          縮小画面(動画)で多人数の画面を一望できる</li>
      </ul>
    </li>
    この内のどれか一つでも問題が解決できれば素晴らしいし,
    もしRemminaにそのような機能がない(上記のような別のソフトウェアもない)
    となったら, 取り込まれる可能性もあるのではと個人的には思う.
  </ul>
</div>

<h2>Remminaのキー捕獲のカスタマイズ</h2>
<div>
<ul>
  <li>対象: <font color=blue>Remmina</font> </li>
  <li>元々なにをするソフトか: デスクトップ共有クライアント</li>
  <li>問題の背景: デスクトップ共有は別のコンピュータの操作を手元でできるようにするためのソフト．そのために，Remminaが受け取ったキー入力を，相手のコンピュータに送り込むということをしている(はず)．</li>
  <li>しかし，一部のキーはホストに処理される．たとえばRemminaの画面にフォーカスがあたっている状態で，Alt-Tab (ウィンドウの上下入れ換え)を押してもそのキー入力は相手コンピュータには伝わらず，手元のホストで処理される．したがって，Remminaではない，別のアプリケーションが前面に移ってきてしまう．この動作が望ましいこともあるが，望ましくない(リモートコンピュータのウィンドウをAlt-Tab切り替えたい)
    こともある．
    <br>実はRemminaには，「全てのキーをキャプチャする」という動作モードも存在する．これを選んでおくと，所望の動作になる．しかしこうすると本当に全てをキャプチャしてしまうので，今度はホスト側で別のアプリに切り替えたいときにマウスに手を伸ばす必要が生ずる．これは耐え難い．</li>
  <li>変更案説明: 
    そこで，「指定したキーはキャプチャしない」という機能をRemminaに付け加える．
  </li>
  <li>一ユーザとして想定している利用場面は以下の通りで出来たら本当に嬉しい．
    <ul>
      <li>Remminaの画面は別のワークスペースに動かした上で全画面表示</li>
      <li>Remminaと他のアプリの切り替えはワークスペースの切り替えキーで行う
	(UbuntuのUnityでは，Ctrl-Alt-矢印. 
	このキーはRemminaにキャプチャさせない)</li>
      <li>Alt-tabはあくまでリモートのコンピュータ内
	でのウィンドウ切り替えに使う</li>
    </ul>
  </li>
  <li>捕捉: 「今度はホスト側で別のアプリに切り替えたいときにマウスに手を伸ばす必要が生ずる．これは耐え難い」と書いたが，「全てのキーをキャプチャするか否か」をキー(右Ctrlキー)でトグルできるので， 右Ctrlキー -> Ctrl-Alt-矢印 というキーシーケンスでホストに戻ることは，可能といえば可能である．右Ctrlキーを押すのはひと手間であるし，なにをキャプチャしたくないかは場面によっても異なるので，一部のキーだけをキャプチャしないでおけるという機能は，それなりに有用ではないかと思われる．
  </li>
</ul>
</div>

<!-----------------------------------------------
<h2>Gnuplotを巨大データに対応させる</h2>
<div>
<ul>
  <li><font color=red>あっさりと出来てしまうことが判明済みなのでおすすめしない
  (むしろ初日の練習用)</font></li>
  <li>対象: <font color=blue>gnuplot</font></li>
  <li>もともと何をするソフトか: グラフの描画・可視化</li>
  <li>問題の背景:
    gnuplotはファイルにあるデータを可視化することができる．
<pre>
gnuplot> plot "a.dat"
</pre>
ここで"a.dat"が非常に巨大なファイル(例えば1000万点)
であったとき，描画に長時間かかるようになる．
一方，単にデータの相関を判断ような目的の場合，
全ての点を律儀に描画する意味がないことも多い．
  </li>
  <li>変更案説明: 
    そこで，plotコマンドを拡張して，
    指定された点の数を等確率で選び出して表示できるようにする．
  </li>
  <li>捕捉: gnuplotに元々備わる似た機能として，everyがある．
    これは指定された個数の点につき一点表示する，という機能．
    ここで目指すのは，表示される点の数が指定できる(つまり，
    データファイルの大きさがどうであっても常に一定数の点だけが表示される)
    というもの．
  </li>
</ul>
</div>
-->

<!---------------------------------------
<h2>Inkscapeに新しい図形を追加</h2>
<div>
<ul>
  <li>対象: <font color=blue>inkscape</font></li>
  <li>もともと何をするソフトか: 描画ツール</li>
  <li>背景説明: inkscapeで最初から用意されている図形は貧弱で，
    円，四角，五角形，星形程度である．例えば矢印などを書きたい
    と思っても最初から備わってはいない．</li>
  <li>変更案説明: 例えば新しい図形として
    矢印を追加することを試みる．
    より野心的には，新しい多角形を容易に追加できる仕組みを作る．
  </li>
</div>
----------------------------------------------->

<!---------------------------------------
<h2>Inkscapeにアニメーション機能追加</h2>
<div>
<ul>
  <li>対象: <font color=blue>inkscape</font></li>
  <li>もともと何をするソフトか: 描画ツール</li>
  <li>背景説明: inkscapeは一つの静止画ファイルを出力するが，
    少しずつ異なる絵を書いておき，
    それら一つのファイルに保存しておきたい，
    ということがしばしば生ずる(例えばアニメーションを作りたい時)
  </li>
  <li>変更案説明: 本当のところ何が追加すべき機能なのかはすぐには
    はっきりしない．以下はひとりごとだと思って読んで下さい．
    例えば元々ある機能として，レイヤという機能がある．
    少しずつ異なる絵を異なるレイヤに保存すれば，複数の絵を一つのファイル
    に保存すればできる(のかも知れない)．よって必要なのは，
    どのレイヤを表示するかを切り替える機能だったり，
    ある図形を，全てのレイヤに自動的に表示されるようにすることかもしれない．
  </li>
  <li>備考: スライドを書くときに，いつもこの機能が欲しくてたまらない．
    個人的にはこれを実現してくれた人には，お小遣いをあげたいくらい(田浦)．
  </li>
</div>
----------------------------------------------->

<!--
<h2>Kdenliveのバグ修正</h2>
<div>
<ul>
  <li>対象: <font color=blue>Kdenlive</font></li>
  <li>もともと何をするソフトか: 動画編集</li>
  <li>背景説明: 
    <a href=http://www.linuceum.com/HintsTips/qikKDEnlive.php>
      このページ</a>の "KDEnlive and .ogv Files" にかかれている
    とおり，KDEnliveには動画クリップ（編集前の素材）の形式として，
    .ogv形式を扱えないという問題がある．
    これは，デスクトップを，recordmydesktop
    というツールでキャプチャして，KDEnliveで編集するときに，
    実際に遭遇した問題．
  </li>
  <li>変更案説明: このバグを修正する．
  </li>
  <li>備考: 逃げ道として，avconf/ffmpegという
    コマンドで，.ovg 形式のファイルを .avi に
    変換すればよいそうで，その意味では深刻な問
    題とは言えないが，最近，実際にこの
    問題に遭遇して時間を消費した身としては，
    直してくれた人に，気持ちばかりの薄給をあげたいという気はする．
    (この逃げ道を勝手に内部で実
    行してくれるだけでも一応の解決策にはなって
    いるので，良い直し方かどうかはともかくとして，
    演習としての手ごろ感はある．)
  </li>
</div>
-->

<!-----------------------------------------------
<h2>Bashのグローバルヒストリ機能</h2>
<div>
<ul>
  <li>対象: <font color=blue>bash</font> (他のシェルでも良い)</li>
  <li>もともと何をするソフトか: コマンドを実行する</li>
  <li>背景説明: シェルには，便利な機能としてヒストリー機能が備わっている．
    最近のコマンドの履歴を覚えておき，上矢印キーや，Ctrl-rで呼び出せる．
    終了時にはヒストリを.bash_historyというファイルに出力して，
    次回起動した時にヒストリを引き継ぐようになっている．
    しかし，複数のシェルを立ち上げていると予期した動作にはならない
    (おそらく，最後に終了したシェルのヒストリだけが残ってしまうため)．
  </li>
  <li>
    同一ユーザが複数のシェルを立ち上げている時に，
    常時，それらの間でヒストリが同期するような機能を実装する．
  </li>
  <li>ググると, 何やらbashの設定で出来るよ的な情報もある.
  </li>
</div>
------------------------------------>

<!------------------------------------------------->
<h2>Bashに並列for文を追加</h2>
<div>
<ul>
  <li>対象: <font color=blue>bash</font> (他のシェルでも良い)</li>
  <li>もともと何をするソフトか: コマンドを実行する</li>
  <li>背景説明: bashには以下のようなfor文が備わっている．
<pre>
for x in .... ; do
  cmd1
  cmd2
  cmd3
  ...
done
</pre>
{ cmd1; cmd2; cmd3; ... }を，... で指定された文だけ順に実行する．
  </li>
  <li>変更案説明: for文と同じシンタクスで，
    pforという，並列for文をサポートする．
    { cmd1; cmd2; cmd3; ... }を，並列に実行する．ただし，
    同時に実行されるコマンド数が一定(環境変数で指定した数
    や搭載コア数)になるように制御する．
  </li>
  <li>補足: <a href="https://fish-osashimi.hatenablog.com/">
      2018年に取り組まれた</a>
  </li>
</ul>
</div>

<!--
<h2>Python, JavaScript, Rubyの末尾再帰除去</h2>
<div>
  <ul>
    <li>対象: <font color=blue>Python, JavaScript, Ruby</font></li>
    <li>もともと何をするソフトか: スクリプト言語</li>
    <li>背景説明: 例えばC言語で以下のようなプログラムを書いて，
<pre>
int fact(int n, double p) {
  if (n == 0) return 1.0;
  else f(n - 1, n * p);
}
</pre> 
fに大きなnを与えればすぐに，再帰呼出しの段数が深くなりすぎて，
スタックオーバーフローする．Python, JavaScript, Rubyなどの
現状の実装でも同様のエラーが起きる．以下はJavaScriptの例で，
JavaScriptの処理系である
<a href=https://code.google.com/p/v8/issues/detail?id=457&q=implement%20tail%20call&sort=-status%20priority%20-id&colspec=ID%20Type%20Status%20Priority%20Owner%20Summary%20HW%20OS%20Area%20Stars>nodeのチケット</a>
にも登録されている．
<pre>
function f(n, a) { 
  if (n == 0) { return a; } 
  else { return f(n - 1, a * n) } 
}; 
fac(100000, 1);
</pre>
問題は，fという関数が非常に深い再帰呼出しをし，
再帰呼出しごとにメモリを消費するということである．
<br>
しかし
プログラミング言語の実装技術として，
末尾再帰呼び出しの除去という手法が知られている．
それは，ある関数呼び出し(f(n - 1, a * n)が，
そのままその親の返り値になるような場所での再帰呼出し
(これを，「末尾」再帰と呼ぶ)であるときは，
親の関数呼び出しのためのメモリを開放してから，
子供の関数呼び出しを行う，という手法である．
実質的には，上記の関数を
<pre>
function f(n, a) { 
start:
  if (n == 0) { return a; } 
  else { a = a * n; n = n - 1; goto start; } 
}; 
</pre>
のように書き換えていることに相当する．この最適化を，
「末尾再帰呼出しの除去」と呼ぶ(<a href=https://ja.wikipedia.org/wiki/%E6%9C%AB%E5%B0%BE%E5%86%8D%E5%B8%B0>wikipedia関連記事</a>)．
</li>
<li>変更案: JavaScript, Python, Rubyなどお好みの言語処理系を
選び，末尾再帰呼出しの除去を実装する．
</li>
    </ul>
  </div>
  -->
  
<!------------------------------------------------->
<h2>Linuxのスケジューラの改変</h2>
<div>
<ul>
  <li>対象: <font color=blue>Linux</font></li>
  <li>もともと何をするソフトか: OS</li>
  <li>背景説明: Linuxは複数のプロセスを同時に実行するために，スケジューラという仕組みを備えている．すべてのプログラムはタスクという単位で扱われ，複数のプロセスを"適当"なタイミングで切り替えながら実行する．この切り替える優先度が高いものほどCPUで実行される時間が長くなり，より短い時間で処理が終わることになる．
  </li>
  <li>
    変更案: プロセス名によって優先度を変えてみる．そのために，まず/proc/sys以下にファイルを置き，linux内の情報を取得できるようにすることになるだろう．
  </li>
</div>

<!------------------------------------------------->
<h2>Mozcの変換候補が邪魔な場所に表示されるのを誰かなんとかして欲しい</h2>
<div>
</div>

<!------------------------
<h2>Mozcの変換候補の変更</h2>
<div>
<ul>
  <li>対象: <font color=blue>Mozc</font></li>
  <li>もともと何をするソフトか: 日本語変換</li>
  <li>背景説明: いわゆるgoogle日本語入力に相当するプログラムがmozcである．Ubuntuなどではキー入力はIM (input method) と呼ばれるプログラム (学科PCではibus) によってmozcに渡され，mozcで変換候補を出すことになる．
  </li>
  <li>
    変更案: 候補をカスタマイズする機能をつける．例えば，"変な"用語を特に重み付けして上位に出すなど．
  </li>
</div>
------------------------->

<!------------------------
<h2>Chromeの新規タブを開いた際のページを変更する</h2>
<div>
<ul>
  <li>対象: <font color=blue>Chrome</font></li>
  <li>もともと何をするソフトか: ブラウザ</li>
  <li>背景説明: Chromeで新しいタブを開くと、標準のGoogleの検索ページが開く。しかし、これをカスタマイズする機能は実装されておらず、プラグインを入れる必要がある。
  </li>
  <li>
    変更案: このページをカスタマイズできるようにする．設定画面からURLを変更できるようになるとなおよい．
  </li>
  <li>補足: <a href="http://fizzy-yuya.hatenablog.com/entry/2016/10/28/151632">
      2016年に取り組まれた</a>
  </li>
</div>
------------------------->

</body>
</html>
